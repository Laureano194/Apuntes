**** JAVASCRIPT - JON MIRCHA ****

Caracter칤sticas y gram치tica:

Unico lenguaje capaz de ejecutarse en 3 capas de una aplicaci칩n.
1-FrontEnd(Js)
2-Backend(NodeJs)
3-Persistencia de datos(MongoDB, Firebase)

Unica tecnolog칤a aceptada por navegadores para programar. 

CARACTER칈STICAS.

-Lenguaje de alto nivel. Nos da abstracciones. No tenemos que recoger basura, por ejemplo.
-Interpretado y din치mico. No necesita fase de compilaci칩n para pasar a fase de ejecuci칩n. Se compila en tiempo de ejecuci칩n.
-Debilmente tipado. Las variables no se casan con un tipo de dato.
-Multiparadigma: POO, programacion funcional, etc.
-Case Sensitive.
-No se necesitan puntos y comas al final de cada linea.

Escritura de c칩digo.

Identificadores deben comenzar con:
-Letra
-Signo d칩lar
-Guion bajo
-Nunca con numeros o caracteres especiales.

Se usa snake_case en ARCHIVOS
Se usa UPPER_CASE en CONSTANTES
Se usa UpperCamelCase en CLASES
Se usa camelCase en VARIABLES, OBJETOS, FUNCIONES, INSTANCIAS

----------------------------------

ORDENAMIENTO DE C칍DIGO.

1- Importaci칩n de m칩dulos
2- Declaraci칩n de variables
3- Declaraci칩n de funciones
4- Ejecuci칩n de c칩digo

---------------------------------

TIPOS DE DATOS

Datos primitivos: Se accede directamente al valor. string, number, boolean, NaN, undefined

Compuestos: Se accede a la referencia del valor:
objeto, array, funcion, clases.

---------------------------------

VARIABLES

Lugar en la memoria para almacenar datos.
쮺칩mo se declara una variable en Javascript?

Las variables tienen un 치mbito de funcionamiento, un scope. "var" era de 치mbito global. No ten칤a 치mbito de bloque. Una variable declarada en un bloque if, for etc tenia tambi칠n 치mbito global.
NO USAR VAR.
Para tener 치mbito de bloque, una variable se declara con "let".

----------------------------------

CONSTANTES

Palabra reservada const. Nos permite guardar constantes. No puede haber constantes vac칤as.
No pueden ser redeclarados ni modificados.

Los objetos y arreglos son valores compuestos, por lo que accedemos a la referencia y no al valor. Por eso SI podemos modificarlo. 

-----------------------------------

STRINGS

let nombre = "Jon"
Pueden ser comillas dobles o simples.
nombre.length // --> 3

nombre.toLowerCase()
apellido.toUpperCase()
lorem.includes("amet") //--> true. Si esta esa palabra.
lorem.trim() // --> Cadena sin espacios al inicio y al final
lorem.split(" ") // --> Genera un arreglo a partir de una cadena separando cada vez que encuentra con el caracter pasado por parametro.

**** Template Strings ****

Concatenacion e interpolacion.
let nombre = "Jon"
let apellido = "Mircha"

//Concatenacion
let saludo = "Hola, mi nombre es " + nombre + " " + apellido

//Interpolacion: Se introducen las variables dinamicamente.
let saludo2= `Hola, mi nombre es ${nombre} ${apellido}`
Se usan acentos invertidos.
Es mas c칩modo tambien al generar c칩digo HTML din치micamente con Javascript.

------------------------------

BOOLEANS

true/false
Existen valores que no son verdaderos ni falsos, pero tienden a valores verdaderos o falsos.
Truthy and Falsyk:
console.log(Boolean(0)); --> false
console.log(Boolean(-1)); --> true
console.log(Boolean("")); --> false
console.log(Boolean("Hola")); --> true

------------------------------

undefined, null & NaN

null y undefined representan un valor ausente, una variable sin valor. undefined es una variable sin valor asignado. Null es un valor asignado intencionalmente por el programador.
NaN:Cuando queremos hacer operaciones aritm칠ticas entre datos que no sean numeros. 
Ejemplo: console.log("hola"*2.5)

-------------------------------

FUNCIONES

Es un bloque de c칩digo independiente al 치mbito global. Se define una sola vez y se reutiliza tantas veces como sea necesario. Pueden recibir argumentos. Son muy poderosas en Javascript porque puedes retornar una nueva funci칩n.

FUNCION DECLARADA

function ejemploFuncion(argumento) {
	console.log(argumento)
}
Invocacion:
ejemploFuncion("UNO") // --> UNO

//Funcion que devuelve valor

function ejemploFuncion() {
	-- Codigo --
	return "Valor devuelto"
}

El return devuelve el valor. Cuando se ejecuta un return corta la funcion, ignorando las lineas siguientes. 

//Asignar valor por defecto a parametro de funcion.

function saludar(nombre="desconocido", edad=0){
}

Una function declarada puede ser invocada antes de la misma. Esto es porque Javascript eleva la funci칩n mediante hoisting.

Otra manera de crear funciones.
//Funcion an칩nima
Se asigna la funcion a una variable. Suele ser const porque el cuerpo de la funcion no cambia.
const funcionExpresada = function() {
	console.log("Esto es una funci칩n expresada, es decir, un valor que se le ha asignado como valor a una variable. No podemos invocarla antes de su definici칩n."
}

Buenas pr치cticas: Ambas opciones son v치lidas. Pero por ello es importante el ordenamiento del c칩digo, por lo cual las funciones deben ser declaradas antes de la ejecuci칩n del c칩digo. La declaraci칩n de funciones de manera expresada evita errores de compilaci칩n por tener mal acomodado el c칩digo. 

---------------------------

ARRAYS

Declarar un arreglo.
Se los puede declarar con la palabra const, ya que el identificador accede a la referencia del valor, y no al valor directamente. Mientras siga siendo un arreglo, sus elementos pueden cambiar sin problemas.
const array = [1, true, "Casa", [1, 2, 3]]
Comienzan en la posicion 0.

const array2 = Array.of("X", "Y", "Z")
const array3 = Array(100).fill(false) 100 posiciones con valor false.
push() agrega elemento al final
pop() elimina el ultimo elemento
forEach(elemento, index) Ejecuta una funcion por cada elemento del arreglo.
1췈 parametro: Elemento del array
2췈 parametro(opcional): Indice del elemento.

---------------------------

OBJETOS

En Javascript, todo es un objeto.
Puedo inicializar un string de la siguiente forma.
let string = new String("Cadena")

Es adecuado trabajar con const al trabajar con objetos.
Pero no es mandatario.
{} // --> Objeto
const obj = {}

Un objeto es una colecci칩n de llaves y valores.
const jon= {
	nombre: "Jon",
	apellido: "Mircha", 
	edad: 35,
	soltero: false,
	contacto: {
		email: "jonmircha@gmail.com",
		twitter: "@jonmircha"
		},
	saludar: () => {
		console.log("Hola")
	}
}
console.log(jon.nombre)
console.log(jon["nombre"])
Las variables de un objeto se llaman ATRIBUTOS, las funciones, M칄TODOS.

console.log(Object.keys(jon)) //Arreglo con todas las llaves.
console.log(Object.values(jon)) // Arreglo con los valores.
console.log(jon.hasOwnProperty("nombre")) // true

------------------------

Operadores:

= // Asignaci칩n de variable
== // Comparacion de valores
=== // Comparacion fuerte(valor y tipo de dato)

i++ // Incremento
i-- // Decremento
i+=2 // Suma 2

Operadores l칩gicos
! // Not
|| // Or
&& // And

------------------------

MANEJO DE ERRORES

Javascript tiene un mecanismo para la detecci칩n y manejo de errores.
try, catch, finally (finally no suele usarse)

En el try se agrega el c칩digo a evaluar. Si hay un error, el catch lo captura.
El finally se ejecutar치 siempre al final.

try {
} catch(error){
} finally{
}

A veces necesito lanzar un error intencionalmente porque estoy pidiendo informaci칩n en un formulario pidiendo datos num칠ricos y llegan como texto.
Al captar el error, corta la ejecucion en el bloque try y salta al catch.

Ejemplo de lanzamiento de errores personalizados.

try{
let num = 10
if (isNaN(num)){
	throw new Error("El caracter introducido no es un numero")
}
} catch(error){
	console.log(`Se produjo el siguiente error: ${error}`)
}
Ventaja de trabajar propios errores es que ser치 mas facil de depurar.

-----------------------

BREAK Y CONTINUE

-----------------------

18 - DESTRUCTURACI칍N

Nueva forma de asignar valores. Se asigna din치micamente lo que viene en un arreglo u objeto a nuevas variables. 

let array = [1, 2, 3]

Tengo un arreglo de n칰meros y tengo la necesidad de guardar cada valor en una variable diferente.

let uno = array[0]
let dos = array[1]
let tres = array[2]

Es mejor hacerlo as칤:
const [uno, dos, tres] = array

let persona = {
	nombre: "Jon",
	apellido: "Mircha",
	edad: 35
}

let { nombre, apellido } = persona
Para que la destructuracion funcione en los objetos, la nueva variable debe llamarse igual que la propiedad del objeto que quiero aislar.

----------------------

19 - OBJETOS LITERALES

Nueva forma de escribir atributos y m칠todos.
let nombre = "kenai"
let edad = 7

const perro = {
	nombre: nombre,
	edad: edad,
	ladrar: function(){
		console.log("WoW")
		}
}

Si el atributo que quieres asignarle a un objeto tiene el mismo nombre que la variable que quieres asignar, puedes simplificar la sintaxis:

const dog = {
	nombre,
	edad,
	raza: "Callejero",
	ladrar(){ //Tambien se simplifica la definicion de m칠todos.
		console.log("WOW WOW")
	}
}

----------------------

20 - PARAMETROS REST & OPERADOR SPREAD

Par치metros REST: Son una forma de ir agregando parametros infinitos a una funci칩n o variable. Se definen anteponiendo 3 puntos. Los parametros extras llegan como un array.

function sumar(a, b, ...c){
let resultado = a + b
c.forEach((num) => resultado += num)
return resultado
}

Spread Operator: 
const array = [1, 2, 3, 4, 5]
const array2 = [6, 7, 8, 9]

const arrayMix = [...array, ...array2]
console.log(arrayMix) // --> [1, 2, 3, 4, 5, 6, 7, 8, 9]

----------------------

21 - ARROW FUNCTIONS

Son una nueva implementaci칩n que simplifica la escritura de funciones.
Se quita la palabra functions y se agrega un =>

const saludar = () => console.loh("Hola")
const saludar = () => {
	console.log("Hola")
}

const saludar = (nombre) => {
	console.log(`Hola ${nombre}`)
}

Puede ser un return implicito.

const sumar = (a, b) => a + b // ESTO NOS DEVUELVE A + B
sumar(1, 2) // --> 3

Capturan el contexto del elemento en el que se encuentran. NO USAR ARROW FUNCTIONS EN OBJETOS.

const perro = {
	nombre: "kenai", 
	edad: 7, 
	ladrar: function() {
		console.log(this) AQUI THIS ES PERRO
	}
}

LA FUNCION COMUN RESPETA EL OBJETO EN QUE SE ENCUENTRA, LA ARROW FUNCTION NO.

const perro = {
	nombre: "kenai", 
	edad: 7, 
	ladrar: () => {
		console.log(this) AQUI THIS ES OBJETO WINDOW
	}
}

La arrow function se saltan el contexto en el que estan y heredan el contexto en el que se encuentra su objeto padre.

----------------------

29 - OPERADOR DE CORTOCIRCUITO

Funcionan poniendo dos condiciones, ya sea usando el operador logico Or o And.
Cortocircuito OR: Cuando el valor de la izquierda en la expresion siempre pueda validar a true, es el valor que se cargar치 por defecto.
Esto se utilizaba para setear un valor por defecto a los parametros de las funciones.

function saludar(nombre){
	nombre = nombre || "desconocido"
	console.log(`Hola ${nombre}`)
} Si nombre no est치 seteado, se setea "desconocido".



Cortocircuito AND: cuando el valor de la izquierda en la expresion siempre pueda validar a false, es el valor que se cargar치 por defecto.

Este se usa para renderizado condicional.

----------------------

EXPRESIONES REGULARES

Secuencias de caracteres que forman un patron de busqueda, principalmente de cadenas de texto.

----------------------

FUNCIONES AN칍NIMAS AUTOEJECUTABLES

Patr칩n muy utilizado para la ejecuci칩n de c칩digo.
Es una funci칩n en la que englobas todo el c칩digo lo que quieres ejecutar.
Se crea una encapsulaci칩n del c칩digo, de manera que lo que se encuentra en la FAA. Entre dos FAA aunque compartan una variable, no entran en conflicto.
Protegido de efectos secundarios de importaci칩n de librerias, etc.

(function(){
	console.log("Mi primer FAA")
})();

(function(){
	console.log("Mi segunda IIFE")
})();

Aqu칤 si es necesario el punto y coma.
La funci칩n se encierra entre parentesis.

쮺omo se reciben parametros?
En los 칰ltimos parentesis.
(function(d, w, c){

})(document, window, console);

Formas de escribir funciones an칩nimas.

Cl치sica:
(function(){
})();

Crockford:
((function(){
})());

Unaria:
+function(){
}();

Facebook:
!function(){
}();

----------------------

M칍DULOS (IMPORT/EXPORT)

Se puede llamar un archivo Javascript externo desde tu JS.

<script src="js/modulos.js" type="module"></script>

Lo primero que se ejecuta son las importaciones de m칩dulos.

Se antepone export a la funcion que se quiere exportar.
Para importarla:
import { funcion } from './directorio'

No se puede usar export default dos veces.
Lo que no llamamos por defecto, se debe hacer destructuracion.

-----------------------

44 - Temporizadores (setTimeOut y setInterval)

Javascript tiene funciones que nos permiten lanzar otras en una cierta cantidad de tiempo.

setTimeOut recibe una callback, es decir, una funcion que va a ejecutar y recibe el tiempo expresado en milisegundos.

setTimeout(() => {
}, 1000);

SetInterval nos sirve si queremos ejecutar lo mismo cada cierto tiempo.

setInterval(() => {
}, 1000);

Hay funciones que los cancelan.
En caso de setTimeout, se llama clearTimeout. Para que funcione, el setTimeOut debe guardarse en una variable, que es la que recibir치 el clearTimeout.

clearSetInterval: Funciona de la misma manera. 

---------------------

45 - ASINCRON칈A

Es un pilar fundamental de Javascript ya que es un lenguaje de un solo hilo, por lo que puede ejecutar una sola cosa a la vez.
No se pueden realizar operaciones largas (Ej: acceso a la red) sin que se bloquee el hilo principal.
Ejemplo: Solicitas datos a una api. Esto puede tardar tiempo. Mientras, el hilo principal se queda bloqueado. Ahi entra el juego la asincron칤a, que permite realizar largas operaciones de red sin bloquear el hilo principal. 
Javascript trabaja bajo un modelo as칤ncrono y no bloqueante y tiene un loop de eventos implementado de un solo hilo para operaciones de entradas y salida. Gracias a esto es un lenguaje altamente concurrente a pesar de ser de un solo hilo. 

Event Loop: Se van registrando las peticiones. Dependiendo del tipo de operacion intensiva que se vaya a hacer(acceso a los ficheros del sistema, solicitar datos a DB, o hacer procesamiento). Se van apilando las tareas y conforme terminen, regresan al event loop que envia un trigger con una notificacion al usuario.
Call Stack: Peticiones que va haciendo la aplicaci칩n se van apilando y dependiendo si son s칤ncronas o as칤ncronas se van liberando o no.

Concurrencia: Cuando dos o mas tareas progresan simultaneamente.
Paralelismo: Dos o mas tareas se ejecutan al mismo tiempo.

Bloqueante/No bloqueante: Siempre hay una fase de espera cuando se ejecuta nuestro c칩digo. Si una operaci칩n es bloqueante, no devuelve el control a la aplicacion hasta que haya terminado su tarea. Las no bloqueantes devuelven inmediatamente el control al hilo principal. 

Operaciones S칤ncronas/As칤ncronas: Se refiere a cuando tendr치 lugar la respuesta. 

S칤ncrono significa que la respuesta sucede en el presente. Una operaci칩n s칤ncrona espera el resultado y sigue. 

En as칤ncrono, la respuesta sucede en un futuro. La operaci칩n as칤ncrona no espera el resultado. Por eso suelta el control y lo regresa al hilo principal. 

En c칩digo s칤ncrono bloqueante, cada operaci칩n se hace de una vez, bloqueando el flujo.

http://latentflip.com/loupe/ 
Esta herramienta muestra como se va ejecutando el c칩digo s칤ncrono bloqueante y el as칤ncrono no bloqueante.

Jvascript tiene distintos mecanismos para trabajar la asincron칤a. Callbacks, promesas, funciones as칤ncronas.

------------------------

46 - CALLBACKS

Es una funci칩n que se ejecuta despu칠s que otra lo haga. Es el mecanismo por excelencia de Javascript para invocar alguna de sus funciones. Primer mecanismo de Javascript para trabajar con asincron칤a. El problema es si hay que trabajar con varias callbacks anidadas (CALLBACK HELL).

El setTimeOut nos sirve para simular la asincron칤a.

function cuadradoCallback(value, callback){
	setTimeout(()=> {
	callback(value, value*value)
	}, 0 | Math.random()*100)
}

cuadradoCallback(0, (value, result)=>{
console.log("Inicia callback");
console.log(`Callback: ${value} ${result}`)
})
Tambien tienen el problema de que en cada callback hay que realizar el manejo de errores. Por eso es mas recomendable utilizar promesas y funciones as칤ncronas.

-----------------------

47 - PROMESAS

Para resolver el manejo de errores en cada funci칩n y el callback hell, Javascript tiene un mecanismo que son las promesas. 

Trabajan con dos recursos principales: El resolve y el reject.
La podemos ver como un if/else. Si la promesa se cumple(Si accedemos al recurso, por ejemplo, los datos que estamos solicitando a una API) se ejecuta el resolve, sino ejecuta el reject. 

function cuadradoPromise(value){
  `Error, el valor ${value} no es un n칰mero.`)
  if (typeof value !== "number") return Promise.reject(
	return new Promise(resolve, reject)=>{
	setTimeout(()=> {
		resolve({
			value : value,
			result : value * value
		)
	}, 1000)
	})	
}

Si es exitoso, nos devuelve el objeto con el valor y el resultado.

cuadradoPromise(2)
	.then(obj=> {console.log(obj)}) // Toma el objeto del resolve.
	.then(obj) //Recibe el objeto que devuelve el then de arriba.
	.catch(error => console.error(err))
	

----------------------

48 - FUNCIONES AS칈NCRONAS : ASYNC / AWAIT

Funciones as칤ncronas esperan a que algo se cumpla para poder seguir ejecutando el proceso. Las promesas vinieron a reemplazar las callbacks. Las funciones asincr칩nicas est치n para trabajar en conjunto con las promesas.
Para el manejo de errores esta el bloque try/catch

async function funcionAsync(){

	try{
		console.log("Inicio Async Function");
		let obj = cuadradoPromise(1)
		console.log(`Async function: ${obj.value} ${obj.result}`)
		let obj2 = {cuadradoPromise(2)
		console.log(`Async function: ${obj.value} ${obj.result}`) 
	} catch(error) {
	}
}

Esto va a devolver undefined en ambos casos, porque la funci칩n tiene un setTimeout.

Para resolver esto, se utiliza await. Esto le dice a Javascript dentro de una funci칩n as칤ncrona que espere el resultado. La palabra reservada async va antes de la declaraci칩n de la funcion.

async function funcionAsync(){

	try{
		console.log("Inicio Async Function");
		let obj = await cuadradoPromise(1)
		console.log(`Async function: ${obj.value} ${obj.result}`)
		let obj2 = await cuadradoPromise(2)
		console.log(`Async function: ${obj.value} ${obj.result}`) 
	} catch(error) {
		console.error(error); //El que devuelve la promesa.
	}
}


const asyncArrowFunc = async () => {

}

Cuando estas pintando elementos del DOM si solicitas datos y automaticamente modificas el DOM dinamicamente sin esperar que la consulta se complete, aparecer치 undefined. 

-----------------------

49 - SYMBOLS

Tipo de dato primitivo. Una vez que lo creamos, su valor se mantiene privado y para uso interno.
No se crea mediante el new, sino mediante el constructor Symbol().

Nos permiten crear identificadores 칰nicos.
let id = "hola"
let id2 = "hola"
console.log(id === id2) // --> true

let id = Symbol("id")
let id2 = Symbol("id2")
console.log(id === id2) // --> false
La cadena de texto es para identificar el symbol.
console.log(typeof id) // --> "symbol"

La buena pr치ctica es crearlos con constantes y may칰sculas.
const NOMBRE = Symbol();
Dentro de un objeto, el Symbol se declara en corchetes.
const persona = {
	[NOMBRE]: "Laureano" // Javascript sabe que hay un simbolo declarado.
}
console.log(persona) // Symbol(): "Laureano"

-------------------------

50 - SETS

Estructura similar a un array, pero solo acepta valores 칰nicos.

let set = new Set([1, 2, 3, 1, "hola", "HOLA", true, false, false, {}, {}])

console.log(set)/-> 1, 2, 3, "hola", "HOLA", true, false, Object, Object

Los object son diferentes. 
El set tiene la propiedad size, no length.
console.log(set.size) // --> 9
const set2 = new Set()
set2.add(1)
set2.add(2)
set2.add(3)
set2.add(3)
console.log(set2) // --> 1, 2, 3

--------------------------

51 - MAPS

Objetos que nos sirven para almacenar valores muy parecido a un objeto primitivo.

let mapa = new Map()

mapa.set("Nombre", "Jon")
mapa.set("Apellido", "Mircha")
mapa.set("edad", 35)

console.log(mapa.size)
console.log(mapa.has("correo")) // --> false
console.log(mapa.get("Nombre")) // --> "Jon"
mapa.set("Nombre", "Jonathan Mircha")
mapa.delete("Apellido")

쮺칩mo recorrer un mapa?
Es un elemento iterable, por lo que se puede utilizar un for of.

for (let[key, value] of mapa):
	console.log(`Llave: ${key}, Valor: ${value}`

----------------------------

56 - PROPIEDADES DIN츼MICAS DE LOS ARREGLOS.

Generar propiedad din치micamente:
Supongamos que tenemos que generar un objeto con el id de cada uno de los elementos de un array.

const objUsuarios = {}
const usuarios = ["jon", "kenai", "elsa"]

usuarios.forEach((usuario, index) => objUsuarios[`id_${index}`] = usuario);

console.log(objUsuarios)
{
id_0: "jon", 
id_1: "kenai",
id_2: "elsa"
}

Otra forma:

random = Math.round(Math.random() * 100 + 5)
const objUsuarios = {
	[`id_${random}`]: "Valor aleatorio"
}

------------------------

57 - THIS

Hace referencia al contexto.
console.log(this) // --> En los navegadores hace referencia al objeto window.

function imprimir(){
	console.log(this)
}
imprimir() // --> Objeto window

const obj = {
	nombre: "Contexto objeto",
	imprimir: function(){
		console.log(this.nombre)
	}
}
obj.imprimir() // --> "Contexto objeto"

Las arrow function no crean un scope. Si llamamos this dentro de un objeto con una arrow function, hara referencia al scope global.

--------------------------

58 - CALL, APPLY, BIND

Tres metodos que nos permiten conservar la referencia de un scope particular.

call sirve para asignar un contexto a una funcion al llamarla.
Bind: Enlazar un contexto a una funcion.

---------------------------

59 - JSON

Javascript Object Notation
Formato ligero de intercambio de datos.
Se ha convertido en un standard. Todos los lenguajes saben interpretar un objeto JSON.
Ha ido desplazando a XML.

const json = {
	cadena: "jon", 
	numero: 12,
	boolean: true,
	arreglo: []
}

se crea un fichero .json.
Las propiedades y los valores deben ir entre comillas.

{
	"cadena": "jon", 
	"numero": "12",
	"boolean": "true",
	"arreglo": []
}

JSON es una interfaz del lenguaje que tiene dos metodos: parse() y stringify().

console.log(JSON.stringify(json))

parse analiza una cadena de texto y lo convierte en un valor v치lido en Javascript.

console.log(JSON.parse("{}")) //--> Object {}
console.log(JSON.parse("[1,2,3]") //--> Array[]

stringify toma un valor valido en Javascript y lo convierte a cadena de texto.

console.log(JSON.stringify({})) //--> "{}"
console.log(JSON.stringify(true)) //--> "true"

------------------------
Aqu칤 termina lo referente a la gram치tica en Javascript.
------------------------

60 - WEB API(Application programming Interface)

En un lenguaje de programaci칩n una API es una serie de objetos y mecanismos que tiene implementado un lenguaje para poder interactuar con otro sistema, en este caso con el DOM.
-Manejo de eventos
-Formularios
-Consumo de datos as칤ncronos con AJAX-Fetch
-History
-Web Storage

DOM(Document Object Model): C칩mo los navegadores representan el codigo HTML para trabajarlo con Javascript. 

------------------------

61 - DOM

Elementos del documento.

Elemento padre: windows

A traves del objeto document, se puede utilizar la notacion punto para acceder a cada parte del document html.
---Obtener el HEAD
console.log(document.head);
console.log(document.body);
console.log(document.documentElement); //Etiqueta HTML
document.charset
document.title
document.links
document.images
document.forms
document.styleSheets
document.scripts
document.getSelection().toString()
document.write("<h1>Hola desde el DOM</h1>") MALA PRACTICA

------------------------

62 - DOM: NODOS, ELEMENTOS Y SELECTORES.

Cada nodo tiee una razon de ser. Los que mas interesan son los nodos de tipo elemento y los nodos de tipo texto. 

document.getElementById("menu")

document.getElementsByTagName("li")
document.getElementsByClassName("container")
document.getElementsByName("nombre")

Los 칰ltimos tres han sido reemplazados por otros dos m칠todos: querySelector y querySelectorAll. El querySelector es m치s lento que getElementById, por eso se sigue usando.

document.querySelector(".menu") Trae el primero.
document.querySelector("#menu li")
document.querySelectorAll("a")

A pesar de no ser arreglos, comparten el metodo length, el forEach.

----------------------

63 - DOM: Atributos y Data-Attributes

document.documentElement.lang
document.documentElement.getAttribute("lang")

- Obtener datos
document.querySelector(".link-dom").href
document.querySelector(".link-dom").getAttribute("href") //Forma mas apropiada

- Establecer nuevo valor
document.documentElement.lang="es"
document.documentElement.setAttribute("lang", "es-MX")

Se pueden guardar los elementos del DOM en variables para no tener que reescribirlos m칰ltiples veces.

Se puede usar const o let.
const $linkDOM = document.querySelector(".link-dom")

Algunos desarrolladores, al guardar en una variable un elemento del DOM, le anteponen el s칤mbolo "$" para poder distinguir que variables tienen que ver con la l칩gica de la aplicacion y cuales refieren a elementos de HTML.

$linkDOM.setAttribute("atributo", "valor")
$linkDOM.setAttribute("target", "_blank")
$linkDOM.setAttribute("href", "www.youtube.com")

-Quitar atributo
$linkDOM.removeAttribute("atributo")
$linkDOM.hasAttribute("target") // --> true

DATA ATTRIBUTES
Leer
$linkDOM.getAttribute("data-description")
$linkDOM.dataset // --> Devuelve un mapa
$linkDOM.dataset.description
Escribir
$linkDOM.setAttribute("data-description", "DOM")
$linkDOM.dataset.description = "Hola amigos de iutu"

-------------------------

64 - DOM: ESTILOS Y VARIABLES CSS

Interactuar con estilos de elementos html.

const $linkDOM = document.querySelector(".link-dom")

$linkDOM.style
style es un mapa de tipo CSS style declaration que agrega todas las propiedades CSS v치lidas. Estan en formato camelCase. Ejemplo: backgroundColor

$linkDom.style.backgroundColor

window.getComputedStyle(elemento)
window.getComputedStyle($linkDOM) Es un objeto diferente que devuelve las propiedades din치micas.

getComputedStyle($linkDOM).getPropertyValue("color")

Setear un estilo
$linkDOM.style.setProperty("text-decoration", "none")
$linkDOM.style.width = "50%";
$linkDOM.style.textAlign = "center";
$linkDOM.style.marginLeft = "auto";

//Variables CSS - Custom Properties.

<style>
:root{
	--yellow-color: #F7DF1E;
	--dark-color: #222;
{
</style>

const $html = document.documentElement;
const $body = document.body;
let varDarkColor = getComputedStyle($html).getPropertyValue("--dark-color");
let varYellowColor = getComputedStyle($html).getPropertyValue("--yellow-color")

body.style.backgroundColor = varDarkColor;
body.style.color = varYellowColor;

Modificar Propiedad
$html.style.setProperty("--dark-color", "pink")

-------------

65 - DOM: CLASES CSS

.card{
      display: inline-block;
     }
.card figcaption{
	  padding: 1rem;
     }
.rotate-45{
	  transform: rotate(45deg);
     }
.rotate-135{
	  transform: rotate(135deg);
     }
.opacity-80{
      opacity: .8;
      }
.sepia{
      filter: sepia(1);
      }
	
const $card = document.querySelector(".card");
console.log($card.className)
console.log($card.classList)
console.log($card.classList.contains("rotate-45") //FALSE
Agregar una clase
$card.classList.add("rotate-45")
console.log($card.classList.contains("rotate-45") //TRUE
Eliminar una clase
$card.classList.remove("rotate-45")

Existe un toggle. Si tiene la clase, la quita, sino la agrega.
$card.classList.toggle("rotate-45")

Reemplazar una clase por otra:
$card.classList.replace("rotate-45", "rotate-135")

Con todos estos m칠todos se pueden agregar y eliminar m치s de una clase a la vez.
Se deben separar por coma.

-------------------

66 - DOM: TEXTO Y HTML

const $whatIsDOM = document.getElementById("que-es")
let text = "<p>El DOM es un API para documentos HTML y XML.</p>"

$whatIsDOM.innerText = text;

innerText no reconoce las etiquetas HTML, las imprime como texto.

La propiedad que forma parte del estandar para agregar contenido textual es textContent.
Tampoco interpreta las etiquetas HTML.

Para ello se utiliza la propiedad innerHTML

$whatIsDOM.innerHTML = text;

Si se necesita insertar solo texto, utilizar textContent. Asi se evita la posibilidad de inyecci칩n de contenido HTML.
El problema es que si se utiliza en una etiqueta <p> y se introducen en el literal string etiquetas <p>, estas quedaran dentro de la otra.
Ejemplo.
<p>
	<p></p>
	<p></p>
	<p></p>
</p>

Esto no es semanticamente correcto o prolijo.

Para ello se utiliza la propiedad outerHTML.

$whatIsDOM.outerHTML = text;
outerHTML reemplaza el elemento del DOM por el contenido del literal string.

------------------

67 - DOM TRAVERSING: Recorriendo el DOM

Serie de propiedades para poder recorrer los elementos.

<section class="cards>
	<figure class="card"></figure>
	<figure class="card"></figure>
	<figure class="card"></figure>
</section>

const $cards = document.querySelector(".cards")
Esto devuelve el section.

console.log($cards.children)
Devuelve una coleccion HTML con los hijos. (figure)

console.log($cards.children[1])
Devuelve el segundo hijo.

console.log($cards.parentElement);
Devuelve el elemento padre.

console.log($cards.firstElementChild);
Devuelve el primer hijo

console.log($cards.previousElementSibling);
console.log($cards.nextElementSibling);
Siguiente y anterior elemento hermano.

console.log($cards.closest("div"))
M칠todo que busca el padre m치s cercano.

--------------

68 - CREANDO ELEMENTOS Y FRAGMENTOS.

Crear elementos dinamicamente a traves de JS.

const $figure = document.createElement("figure"),
$img = document.createElement("img"),
$cards = document.querySelector(".cards");

$img.setAttribute("src", "{Link a imagen}")
$figure.appendChild($img)
$figure.appendChild($figCaption)

$cards.appendChild($figure);


const estaciones = ["Primavera", "Verano", "Oto침o", "Invierno"]

$ul = document.createElement("ul")
document.body.appendChild($ul)

estaciones.forEach( el => {
	$li = document.createElement("li")
	$li.textContent = el
	$ul.appendChild($li)
}

O ...

const continentes = ["Am칠rica", "Ocean칤a", "Europa", "Asia", "츼frica"]

$ul2 = document.createElement("ul")
document.body.appendChild($ul2)

continentes.forEach(el => {
$ul2.innerHTML = ""
$ul2.innerHTML += `<li>{el}</li>`
}

El problema es cuando necesitamos renderizar muchos elementos. A cada iteraci칩n del forEach estamos agregando un elemento al DOM, en este caso a la ul.
Las inserciones al DOM son de las operaciones mas demandantes. Cuando se deben renderizar decenas o cientos de productos, se ralentizar치 la aplicaci칩n.

Para esto existen los fragmentos. Una vez que se llena el fragmento con todos los registros, se hace una sola inserci칩n al DOM.

const meses = [
	"enero",
	"febrero",
	"marzo",
	"abril",
	...
}

$ul3 = document.createElement("ul")
document.body.appendChild($ul3)
$fragment = document.createDocumentFragment()
meses.forEach(mes => {
	const $li = document.createElement("li")
	$li.textContent = mes
	$fragment.appendChild($li)
})
document.body.appendChild
$ul3.appendChild($fragment)
document.body.appendChild($ul3)

Esta es una forma m치s 칩ptima para no consumir tantos recursos al navegador.

-----------

69 - DOM: Templates HTML

<template id="template-card")>
</template>

const $cards = document.querySelector(".cards"),
$template = document.getElementById("template-card").content
$fragment = document.createDocumentFragment();

cardContent = ["", "", "", "",]

cardContent.forEach(el => {

$template.querySelector("img").setAttribute("src", el.img)
$template.querySelector("img").setAttribute("alt", el.title)
$template.querySelector("figcaption").textContent = el.title

let $clone = document.importNode($template, true)
El true es que se copia el contenido, y no solo la etiqueta template.
$fragment.appendChild($clone)
})
$cards.appendChild($fragment);

Las etiquetas template no se renderizan en el DOM. Sirven de modelo.

---------------------

71 - DOM: Modificando elementos.

M칠todos para insertr HTML. 
.insertAdjacentElement(position, element)
.insertAdjacentHTML(position, HTML)
.insertAdjacentText(position, text)

Posiciones disponibles:
beforebegin(hermano anterior)
afterbegin(primer hijo)
beforeend(ultimo hijo)
afterend(hermano siguiente)

const $cards = document.querySelector(".cards"),
$newCard = document.createElement("figure");
$newCard.classList.add("card")

let $cardContent.innerHTML = `
<img src="www.source.com" alt="Any">
<figcaption></figcaption>
`;

$newCard.insertAdjacentElement("afterbegin", $cardContent)
//En este caso, es lo mismo afterbegin o beforeend, pero tiene que ser un hijo.

$newCard.querySelector("figcaption").insertAdjacentText("afterbegin", "Any");

Tambi칠n est치n los m칠todos.
$cards
.prepend($newCard) Primer hijo
.append() Ultimo hijo
.before() Hermano anterior
.after() Hermano posterior

---------------

72 - DOM: Manejadores de eventos

 * 游닇 Los Eventos

    游녤 Es aquel mecanismo que tenemos en JS para poder controlar las acciones del usuario y definir ciertos comportamientos del documento q sucedan en cierto momento o cuando se cumplan algunas condiciones.

    游녤 Ahora, las funciones q se ejecutan en un Evento es lo q se conoce como el Event Handler o traducido Manejadores de Eventos, o tmb Observadores o Escuchadores.

    游녤 Hay 3 maneras de definir los Eventos en JS : 

	1 - COMO ATRIBUTO DEL HTML

<button onclick="aqui va el c칩digo JS"></button>
<button onclick="holaMundo()"></button>

   游 Muy importante: 
	
   游녤 No es la mejor forma
	
   游녤 Esta funci칩n se va a convertir en el Manejador de Eventos (Event Handler)

   游녤 Cuando una funci칩n se convierte en un Event Handler, es decir una funci칩n que se ejecuta en un Evento, nosostros podemos acceder a un Objeto especial q es el Evento en s칤, y eso lo podemos acceder con la palabra reservada 'event'
	En el ejemplo, se accede a un objeto de tipo Mouse Event.
   

    function holaMundo(){

       alert('Holaaa Mundo')

       console.log(event)  //游녣 con esto en la consola, se desencadena un tipo de Objeto MouseEvent (evento del Mouse), y dentro de 칠l se encuentran dos propiedades muy importantes: type y target.       

      //游녤 type.- es el tipo de evento q se desencadeno

      //游녤 target.- es el elemento que origino el evento

      //游녤 Dentro de target estan todos los eventos y propiedades q se pueden usar por dicho elemento y los q estan en null son eventos q no tienen definida dicha funci칩n en dichos eventos. En cambio vemos el evento onclick q si tiene definida la funcion holaMundo

    }

   2 - COMO MANEJADOR SEM츼NTICO

   游녤 Esta forma es m치s correcta.

   游녤 Se le dice manejador sem치ntico xq va teniendo una coherencia en la manera como la vamos definiendo

   游녤 cuando definamos un evento como sem치ntico igualamos el evento sem치ntico al nombre de la funcion pero sin (), xq los () hacen q cuando se cargue el Navegador se va a ejecutar
	
	<button id="evento-semantico"> Evento como manejador sem치ntico</button>
		
    const $eventoSemantico = document.getElementById('evento-semantico')

    $eventoSemantico.onclick = holaMundo //游녣 no le ponemos () a la funci칩n xq sino al momento q se recarga el Navegador, se estar치 ejecutando el evento, y luego la consola nos dar치 undefined, xq el objeto event q mandamos a la consola no estar치 definido, xq la funci칩n se ejecut칩 asi como va, osea a la hora de cargar como tiene los parentesis se ejecuta.

    

   游녢 esta es otra manera de definir un Evento de tipo sem치ntico, puede ser una funci칩n an칩nima o una arrow function

     $eventoSemantico.onclick = function(e){  //游녣 Toda funci칩n q se convierte en un Manejador de Eventos, es decir una funci칩n q se ejecuta en algun momento en un evento no puede recibir par치metros, el 칰nico par치metro q recibe es el evento en s칤, que lo podemos obtener con la palabra 'event' o en algunos casos abreviar con la letra 'e'

        alert(`Hola Manejador de Evento Sem치ntico`)

        console.log(e)

        console.log(event)

     }

   3 - COMO MANEJADOR M칔LTIPLE

   游녤 Si deseamos asignar varias funciones a un mismo elemento, tenemos el m칠todo .addEventListener() que nos perimite levantar un Escuchador de Eventos

   const $eventoMultiple = document.getElementById('evento-multiple')

   游녢 este m칠todo .addEventListener() recibe varios par치metros, pero s칩lo nos enfocaremos en 2:

   1춿 Nombre de evento

   2춿 Funci칩n q se va a ejecutar, pero sin parentesis

   $eventoMultiple.addEventListener('click', holaMundo)

   

   //游녢 tmb podemos trabajar con una arrow function

   $eventoMultiple.addEventListener('click', (e) => { //游녣 este addEventListener nos dar치 2 alerts y 4 console.log, nos da 2 alerts xq en vez de reemplazar como pasa m치s arriba con el evento de tipo sem치ntico, esta es la ventaja de maneja evento m칰ltiple con addEventListener xq puede ejecutar m치s funciones

      alert(`Hola Manejador de Evento M칰ltiple`)

      console.log(e)

      console.log(e.type)

      console.log(e.target)

      console.log(event)

   } )

   //游닇NOTA:

   //游녤 Cuando escuchemos de Event Handler hacemos referencia a la funci칩n q se ejecuta en dicho Evento   

   //游녤 Una misma funci칩n nos puede servir para desencadenar eventos en diferentes elementos

   //游녤 Los eventos sem치nticos tienen un peque침o inconveniente, si nos damos cuenta, cuando hablabamos de los Prototipos y hablamos de la funcion constructora, y si queriamos agregarle m치s m칠todos teniamos q agregarle a su Prototipo, aqui pasa algo similar, el onclick es como agregarle un m칠todo al Prototipo del Modelo de eventos del elemento del DOM q se estamos manejando

   //游녤 Habr치 veces q a lo mejor a un mismo elemento Html le asignemos diferentes Manejadores de Eventos, es decir diferentes funciones q hagan diferentes cosas, bueno la limitante q tienen los eventos de tipo sem치ntico, es q una vez q esta definido el evento sem치ntico s칩lo va poder ejecutar una funci칩n.

   //游녤 Toda funci칩n q se convierte en un Manejador de Eventos, es decir una funci칩n q se ejecuta en alg칰n momento en un evento no puede recibir par치metros, el 칰nico par치metro q recibe es el evento en s칤, que lo podemos obtener con la palabra 'event' o en algunos casos abreviar con la letra 'e'

-----------------

73 - DOM: Eventos con Par치metros y Remover Eventos

Cualquier funcion que se ejecute en un evento, solo puede recibir como parametro el evento en si.

function saludar(nombre = "desconocid@"){
	alert(`Hola ${nombre}`)
}

$eventoMultiple.addEventListener("click", saludar)

Hola [object MouseEvent]
Aunque tenga un parametro con un valor por defecto(en este caso nombre) no lo toma.

$eventoMultiple.addEventListener("click", ("Laureano")=>saludar());

Envolviendo la funci칩n manejadora de eventos en una arrow function permite pasar par치metros.

ELIMINAR EVENTOS DE UN ELEMENTO.

<button id="evento-remover">Remover</button>

$eventoRemover = document.getElementById("evento-remover")
$eventoRemover.removeEventListener(evento, funcionManejadora) // Por eso no se puede eliminar una arrow function.

$eventoRemover.removeEventListener("dblclick", removerDblClick)

---------------------

75 - DOM: stopPropagation & preventDefault 

---------------------

105 - AJAX: Introducci칩n
AJAX no es una tecnolog칤a en si misma, sino un conjunto de tecnolog칤as.
Asynchronous Javascript and XML
XML ha quedado de lado con JSON.
Mecanismo de Javascript para trabajar con la asincronia y hacer peticiones al lado del servidor.
Gracias a AJAX ya no es necesario que se recargue el navegador al hacer una petici칩n. Ejemplo, un mail se agrega al tope de la lista sin tener que recargar la web.

Hay tres m칠todos nativos para hacer AJAX.
ActiveXObject(obsoleto)
XMLHttpRequest
API Fetch(moderno)

La m치s popular de las librerias externas es AXIOS.
Est치 basado en promesas.

-----------------

 107 - AJAX: API Fetch